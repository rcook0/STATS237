from __future__ import annotations

import importlib
import json
import pkgutil
import sys
from dataclasses import dataclass
from pathlib import Path
from typing import Iterable, List

ROOT = Path(__file__).resolve().parents[1]
BOOK_DOCS = ROOT / "book" / "docs"
GEN = BOOK_DOCS / "_generated"


def _read_text(p: Path) -> str:
    return p.read_text(encoding="utf-8") if p.exists() else ""


def write_materials_index() -> None:
    reg = ROOT / "registry" / "materials_registry.json"
    lines = ["# Materials Index", ""]
    if not reg.exists():
        lines += [
            "No `registry/materials_registry.json` found yet.",
            "",
            "Run ingestion:",
            "",
            "```bash\npython scripts/ingest.py\n```",
        ]
    else:
        data = json.loads(reg.read_text(encoding="utf-8"))
        items = data.get("materials", [])
        lines.append(f"Found **{len(items)}** materials in the registry.")
        lines.append("")
        lines.append("| name | pages | sha256 |")
        lines.append("|---|---:|---|")
        for it in items:
            lines.append(f"| {it.get('name','')} | {it.get('pages','')} | `{it.get('sha256','')[:16]}â€¦` |")
        lines.append("")
        lines.append("_Tip: keep PDFs in `materials/` after ingestion, and link them from chapters._")
    (GEN / "materials_index.md").write_text("\n".join(lines) + "\n", encoding="utf-8")


def iter_public_functions(modname: str) -> List[str]:
    try:
        m = importlib.import_module(modname)
    except Exception:
        return []
    names = []
    for k, v in vars(m).items():
        if k.startswith("_"):
            continue
        if callable(v):
            names.append(k)
    return sorted(set(names))


def discover_quantlib_modules(pkg: str) -> List[str]:
    try:
        p = importlib.import_module(pkg)
    except Exception:
        return []
    mods = []
    if hasattr(p, "__path__"):
        for m in pkgutil.walk_packages(p.__path__, prefix=pkg + "."):
            if not m.ispkg:
                mods.append(m.name)
    return sorted(mods)


def write_function_index() -> None:
    # Attempt import in editable installs
    sys.path.insert(0, str(ROOT / "stats237_quantlib"))

    pkg = "stats237_quantlib"
    lines = ["# Function Index", "", "This index is generated by importing the quant library.", ""]

    mods = discover_quantlib_modules(pkg)
    if not mods:
        lines += [
            "Quantlib not importable yet.",
            "",
            "Install it in editable mode:",
            "",
            "```bash\npython -m pip install -e stats237_quantlib\n```",
        ]
    else:
        lines.append(f"Discovered **{len(mods)}** modules under `{pkg}`.")
        lines.append("")
        for mod in mods:
            funcs = iter_public_functions(mod)
            if not funcs:
                continue
            lines.append(f"## `{mod}`")
            lines.append("")
            for fn in funcs:
                lines.append(f"- `{fn}`")
            lines.append("")

    (GEN / "function_index.md").write_text("\n".join(lines) + "\n", encoding="utf-8")


def sync_markdown() -> None:
    # course story
    cs_src = ROOT / "discourse" / "course_story.md"
    cs_dst = BOOK_DOCS / "course_story.md"
    if cs_src.exists():
        cs_dst.write_text(cs_src.read_text(encoding="utf-8"), encoding="utf-8")

    # api + reproducibility
    for name in ["api.md", "reproducibility.md"]:
        src = ROOT / "docs" / name
        dst = BOOK_DOCS / name
        if src.exists():
            dst.write_text(src.read_text(encoding="utf-8"), encoding="utf-8")


def main() -> None:
    GEN.mkdir(parents=True, exist_ok=True)
    sync_markdown()
    write_materials_index()
    write_function_index()


if __name__ == "__main__":
    main()
