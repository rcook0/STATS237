#!/usr/bin/env python3
"""Generate pytest cases from `problem_bank/test_specs.yaml`.

The generated tests are intentionally **thin**:
- If a spec is incomplete (oracle.kind == "pending" or missing params/expected), the test is marked xfail.
- Once you fill in `call.params` + `oracle.expected`, the test automatically becomes active.

This is the fastest way to turn a pile of PDFs into an executable spec.
"""

from __future__ import annotations

import datetime
from pathlib import Path

import yaml


ROOT = Path(__file__).resolve().parents[1]
TEST_SPECS = ROOT / "problem_bank" / "test_specs.yaml"
OUT = ROOT / "stats237_quantlib" / "tests" / "spec" / "test_problem_specs_generated.py"


TEMPLATE = """# AUTO-GENERATED by scripts/generate_problem_tests.py
# Do not edit this file directly. Edit problem_bank/test_specs.yaml instead.

from __future__ import annotations

import importlib

import pytest
import yaml

from pathlib import Path


ROOT = Path(__file__).resolve().parents[3]
SPECS = ROOT / "problem_bank" / "test_specs.yaml"


def _resolve(dotted: str):
    mod, _, name = dotted.rpartition(".")
    if not mod:
        raise ValueError(f"Bad dotted path: {dotted}")
    m = importlib.import_module(mod)
    return getattr(m, name)


def _load_specs():
    data = yaml.safe_load(SPECS.read_text())
    return data["problems"]


@pytest.mark.parametrize("spec", _load_specs(), ids=lambda s: s.get("id", "unknown"))
def test_problem_spec(spec):
    pid = spec.get("id")
    fn = spec.get("function")
    params = (spec.get("call") or {}).get("params") or {}
    oracle = spec.get("oracle") or {}
    kind = oracle.get("kind", "pending")

    # Gate 1: must have a callable and some params (unless invariant tests are purely structural)
    if not fn:
        pytest.xfail(f"{pid}: no function mapped yet")
    if kind == "pending":
        pytest.xfail(f"{pid}: spec pending (fill oracle.kind/expected/params)")

    f = _resolve(fn)

    # Call
    try:
        out = f(**params)
    except TypeError as e:
        pytest.xfail(f"{pid}: params don't match callable yet: {e}")

    # Oracle
    if kind == "numeric":
        expected = oracle.get("expected")
        if expected is None:
            pytest.xfail(f"{pid}: missing oracle.expected")
        tol = oracle.get("tolerance") or {}
        rtol = float(tol.get("rtol", 1e-6))
        atol = float(tol.get("atol", 1e-9))

        # expected can be a number or a dict with 'field'
        if isinstance(expected, dict) and "field" in expected and "value" in expected:
            field = expected["field"]
            exp = float(expected["value"])
            if isinstance(out, dict):
                got = float(out[field])
            else:
                pytest.fail(f"{pid}: expected dict output to select field '{field}'")
        else:
            exp = float(expected)
            got = float(out)

        assert got == pytest.approx(exp, rel=rtol, abs=atol)

    elif kind == "invariant":
        # Invariant tests are expressed as small python expressions in `oracle.assertions`.
        assertions = oracle.get("assertions") or []
        if not assertions:
            pytest.xfail(f"{pid}: invariant oracle missing oracle.assertions")
        env = {"out": out, "params": params}
        for expr in assertions:
            assert bool(eval(expr, {}, env)), f"{pid}: invariant failed: {expr}"
    else:
        pytest.xfail(f"{pid}: unknown oracle kind '{kind}'")
"""


def main() -> None:
    if not TEST_SPECS.exists():
        raise SystemExit(f"Missing {TEST_SPECS}. Run scripts/build_test_specs.py first.")

    now = datetime.datetime.now(datetime.timezone.utc).isoformat()
    OUT.parent.mkdir(parents=True, exist_ok=True)

    # validate YAML loads
    yaml.safe_load(TEST_SPECS.read_text())
    OUT.write_text(TEMPLATE + f"\n# generated_at: {now}\n")
    print(f"Wrote {OUT}")


if __name__ == "__main__":
    main()
